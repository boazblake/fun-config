{"version":3,"sources":["../../src/pointfree.mjs"],"names":["ParseError","Error","id","x","_groupsOf","n","xs","length","slice","concat","mjoin","mmv","mconcat","empty","reduce","sequenceA","point","fctr","traverse","of","f","foldMap","fldable","acc","r","fold","g","toList","y","eitherToTask","cata","Left","e","Task","rejected","Right","promiseToTask","p","rej","res","then","taskToPromise","t","Promise","fork","parse","Either","try","JSON"],"mappings":"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","file":"pointfree.js","sourcesContent":["import { chain, curry, compose, concat, map, prop } from 'ramda'\r\nimport Either from 'data.either'\r\nimport Task from 'data.task'\r\n\r\nexport class ParseError extends Error {}\r\n\r\nconst id = (x) => x\r\n\r\nconst _groupsOf = curry((n, xs) =>\r\n  !xs.length ? [] : [xs.slice(0, n)].concat(_groupsOf(n, xs.slice(n, length)))\r\n)\r\n\r\nexport const mjoin = (mmv) => {\r\n  if (mmv.mjoin) return mmv.mjoin()\r\n  return chain(id, mmv)\r\n}\r\n\r\nexport const mconcat = curry((xs, empty) =>\r\n  xs.length ? xs.reduce(concat) : empty()\r\n)\r\n\r\nexport const sequenceA = curry((point, fctr) => {\r\n  return fctr.traverse(id, point)\r\n})\r\n\r\nexport const of = (x) => x.of\r\n\r\nexport const traverse = curry((f, point, fctr) =>\r\n  compose(\r\n    sequenceA(point),\r\n    map(f)\r\n  )(fctr)\r\n)\r\n\r\nexport const foldMap = curry((f, fldable) =>\r\n  fldable.reduce((acc, x) => {\r\n    const r = f(x)\r\n    acc = acc || r.empty()\r\n    return acc.concat(r)\r\n  }, null)\r\n)\r\n\r\nexport const fold = curry((f, g, x) => x.fold(f, g))\r\n\r\nexport const toList = (x) => x.reduce((acc, y) => [y].concat(acc), [])\r\n\r\nexport const eitherToTask = (x) =>\r\n  x.cata({\r\n    Left: (e) => Task.rejected(new ParseError(e)),\r\n    Right: (x) => Task.of(x),\r\n  })\r\n\r\nexport const promiseToTask = (p) => new Task((rej, res) => p.then(res, rej))\r\nexport const taskToPromise = (t) => new Promise((res, rej) => t.fork(rej, res))\r\n\r\nexport const parse = Either.try(\r\n  compose(\r\n    JSON.parse,\r\n    prop('response')\r\n  )\r\n)\r\n"]}